---


---

<h1 id="zadanie-rekrutacyjne-pointa">Zadanie rekrutacyjne Point’a</h1>
<p>Witaj wędrowcu!<br>
Widzę że przypadł ci zaszczyt przygotowania się do rozmowy kwalifikacyjnej do Pointa.</p>
<p>Czeka cię doświadczenie pełne przygód i życiowych lekcji zmuszających do przemyśleń nad naturą egzystencja oraz kierunkami swojej kariery.</p>
<p>Nie zwlekając dalej przedstawię ci jak może brzmieć polecenie twojego zadania.</p>
<blockquote>
<p>Znajdź i rozwiąż problem z płynnością animacji w aplikacji pod podanym <a href="https://stackblitz.com/edit/an-angular-6rpvrq?file=src/index.html">linkiem</a></p>
</blockquote>
<p>Tyle.</p>
<p>Baw się dobrze.</p>
<h2 id="co-nas-czeka">Co nas czeka?</h2>
<p>Po otwarciu linka zobaczymy aplikacje na stackblitz która wyświetla taka aplikacje</p>
<iframe height="600" width="800" src="https://stackblitz.com/edit/an-angular-6rpvrq?ctl=1&amp;embed=1&amp;file=src%2Findex.html&amp;hideExplorer=1&amp;hideNavigation=1&amp;view=preview">&#10;<p>Za &#322;adna to ona nie jest ale to jest kompletnie nie istotne. Od razu wida&#263; problem z tym &#380;e animowany okr&#261;g nie porusza si&#281; p&#322;ynnie tylko skokowo. Zatem pierwszym instynktem jest sprawdzeniem jak jest tworzony okr&#261;g oraz w jaki spos&#243;b jest animowany, prawda?</p>&#10;<h2 id="komponent-okr&#281;gu">Komponent okr&#281;gu</h2>&#10;<p>Je&#347;li p&#243;jdziemy do pliku <code>pretty-animation.component.ts</code> zobaczymy kod naszego okr&#281;gu.</p>&#10;<pre><code class="prism language-typescript">import { Component, ElementRef, OnInit, inject } from '@angular/core';&#10;&#10;@Component({&#10;  selector: 'app-pretty-animation',&#10;  templateUrl: './pretty-animation.component.html',&#10;  styleUrls: ['./pretty-animation.component.css'],&#10;  imports: [],&#10;  standalone: true,&#10;})&#10;export class PrettyAnimationComponent implements OnInit {&#10;  x = 0;&#10;  dx = 5;&#10;  color = [255, 0, 0];&#10;  element = inject(ElementRef);&#10;  start = Date.now();&#10;  frame = 0;&#10;  ngOnInit() {&#10;    this.computeNextFrame();&#10;  }&#10;&#10;  computeNextFrame() {&#10;    this.frame++;&#10;    const rect = this.element.nativeElement.getBoundingClientRect();&#10;    this.x = (Date.now() - this.start) / 5;&#10;    this.x %= rect.width - 80;&#10;    const [r, g, b] = this.color;&#10;    this.color = [&#10;      this.clampColor(r + (Math.random() - 0.5) * 30),&#10;      this.clampColor(g + (Math.random() - 0.5) * 30),&#10;      this.clampColor(b + (Math.random() - 0.5) * 30),&#10;    ];&#10;&#10;    if (this.frame % 120 === 0) {&#10;      console.log('frame', this.frame);&#10;    }&#10;&#10;    setTimeout(() =&gt; this.computeNextFrame(), Math.floor(1000 / 60));&#10;  }&#10;&#10;  clampColor(a: number) {&#10;    return Math.max(0, Math.min(a, 255));&#10;  }&#10;&#10;  get rgb() {&#10;    return `rgb(${this.color.join(', ')})`;&#10;  }&#10;}&#10;</code></pre>&#10;<p>Pomi&#324;my fakt &#380;e kontrolujemy animacje elementu kt&#243;ry tylko ma si&#281; przesuwa&#263; od lewej do prawej z losow&#261; zmiana koloru u&#380;ywamy kodu w TS zamiast po prostu po bo&#380;emu zrobi&#263; to prost&#261; animacja w CSS kt&#243;ra by uzyska&#322;a taki sam efekt w lepszy spos&#243;b.<br/>&#10;Zak&#322;adamy &#380;e jest jakie&#347; przerastaj&#261;ce nasze pojmowanie wymaganie kt&#243;ra zmusza nas do tego wi&#281;c musimy si&#281; przyjrze&#263; logice samej sobie.</p>&#10;<p>Dla wi&#281;kszo&#347;ci os&#243;b podejrzane b&#281;d&#261; dwie linie</p>&#10;<pre><code class="prism language-typescript">this.x =  (Date.now()  -  this.start)  /  5;&#10;</code></pre>&#10;<p>oraz</p>&#10;<pre><code class="prism language-typescript">setTimeout(()  =&gt;  this.computeNextFrame(), Math.floor(1000  /  60));&#10;</code></pre>&#10;<p>Wi&#281;c po kolei.</p>&#10;<h3 id="co-robi-pierwsza-linia">Co robi pierwsza linia?</h3>&#10;<p>Ustawia X na 1/5 czasu mi&#281;dzy startem a obecnym czasem ale jak przepiszemy inaczej</p>&#10;<pre><code class="prism language-typescript">const time = Date.now() - this.start);&#10;const speed = 1/5;&#10;this.x = time * speed;&#10;</code></pre>&#10;<p>Wi&#281;c ta X b&#281;dzie po prostu dystansem kt&#243;ry powinien do tego czasu pokona&#263; okr&#261;g od startu animacji. Nic strasznego. Zabezpieczeniem przed tym &#380;eby okr&#261;g nie uciek&#322; nam z ekranu jest linia</p>&#10;<pre><code class="prism language-typescript">this.x %= rect.width -  80; &#10;</code></pre>&#10;<h3 id="to-mo&#380;e-druga-jest-problemem">To mo&#380;e druga jest problemem?</h3>&#10;<p><strong>Nie.</strong></p>&#10;<p><em>No dobra mo&#380;e troch&#281; ale do tego wr&#243;cimy</em></p>&#10;<p>Jedyne co z punktu widzenia tego komponentu robi to triggeruje renderowanie nast&#281;pnej klatki animacji za 1/60 sekundy poniewa&#380; chcemy by animacja dzia&#322;a&#322;a w 60kl/s.</p>&#10;<h2 id="drugi-komponent">Drugi komponent</h2>&#10;<p>Nasza ma&#322;a testowa aplikacja sk&#322;ada si&#281; z dw&#243;ch element&#243;w, Animacji oraz tajemniczej tabelki wi&#281;c mo&#380;emy si&#281; zainteresowa&#263; co si&#281; dzieje w tym drugim je&#347;li na pierwszy rzut oka nie ma wi&#281;kszych problem&#243;w z komponentem animacji.</p>&#10;<p>Gdy p&#243;jdziemy  do <code>results-table.component.html</code></p>&#10;<pre><code class="prism language-html">&lt;table&gt;&#10;  &lt;caption&gt;&#10;    Todos table with&#10;    {{&#10;      (todos$ | async)?.length&#10;    }}&#10;    results&#10;  &lt;/caption&gt;&#10;  &lt;tr&gt;&#10;    &lt;th&gt;Value&lt;/th&gt;&#10;    &lt;th&gt;Completed&lt;/th&gt;&#10;    &lt;th&gt;Computed Value&lt;/th&gt;&#10;  &lt;/tr&gt;&#10;  &lt;tr *ngFor=&#34;let todo of todos$ | async&#34;&gt;&#10;    &lt;td&gt;{{ todo.title }}&lt;/td&gt;&#10;    &lt;td&gt;{{ todo.completed }}&lt;/td&gt;&#10;    &lt;td&gt;{{ sumSquaresUpToN(todo.value) }}&lt;/td&gt;&#10;  &lt;/tr&gt;&#10;&lt;/table&gt;&#10;&#10;</code></pre>&#10;<p>to nie ma tu nic zaskakuj&#261;cego po za wyja&#347;nieniem sk&#261;d si&#281; wzi&#281;&#322;y tak du&#380;e cyfry w trzeciej kolumnie tabeli.</p>&#10;<p>Popatrzymy zatem na logik&#281; tego komponentu</p>&#10;<pre><code class="prism language-typescript">import { CommonModule } from '@angular/common';&#10;import { ChangeDetectionStrategy, Component, inject } from '@angular/core';&#10;import { TodosService } from '../todos.service';&#10;&#10;@Component({&#10;  selector: 'app-results-table',&#10;  templateUrl: './results-table.component.html',&#10;  styleUrls: ['./results-table.component.css'],&#10;  standalone: true,&#10;  imports: [CommonModule],&#10;})&#10;export class ResultsTableComponent {&#10;  service = inject(TodosService);&#10;  todos$ = this.service.getTodos();&#10;&#10;  sumSquaresUpToN(n: number): number {&#10;    let sum = 0;&#10;    for (let i = 1; i &lt;= n; i++) {&#10;      sum += i ** 2;&#10;    }&#10;    return sum;&#10;  }&#10;}&#10;</code></pre>&#10;<p>Widzimy &#380;e <code>sumSquaresUpToN</code> nawet nie sta&#322;o obok zoptymalizowanego kodu wi&#281;c nawet je&#347;li <code>todo.value</code> u&#380;ywane jako parametr funkcji jest generowane w serwisie poprzez</p>&#10;<pre><code class="prism language-typescript">value: (Math.random() * 20_000_000) | 0,&#10;</code></pre>&#10;<p>to nawet je&#347;li obliczenie tego dla n z zakresu 0 - 20 000 000 mo&#380;e i potrawa chwil&#281; ale zrobi si&#281; to tylko raz dla ka&#380;dego wiersza prawda?</p>&#10;<p><strong>Prawda?</strong></p>&#10;<h3 id="prawda">Prawda?</h3>&#10;<p>Sp&#243;jrzmy zatem na flamegraph<br/>&#10;<img src="https://i.imgur.com/yPSiour.png" alt="Flamegraph dla sekundy &#380;ycia aplikacji"/></p>&#10;<p>Sza&#322;u nie ma bo funkcja <code>sumSquaresUpToN</code> jest wykonywana co chwila i zajmuje oko&#322;o 140ms czyli stanowczo wi&#281;cej ni&#380; oczekiwane 16ms potrzebne do stabilnego 60kl/s.</p>&#10;<p>Jak spojrzymy na pocz&#261;tek stosu kt&#243;ry zaowocowa&#322; ponownym przeliczeniem tej ci&#281;&#380;kiej funkcji to zobaczymy &#380;e wszystkie te ramki zosta&#322;y zainicjowane przez <code>Task</code> z <code>TimerFired</code>.</p>&#10;<p>Jedyny taskiem z timerem w aplikacji jest kolejkowanie nast&#281;pnych klatek w animacji. Wi&#281;c to jego wina?</p>&#10;<p>Tak i nie.</p>&#10;<p>Tak poniewa&#380; ka&#380;dy callback odpalony z setTimeout wywo&#322;a sprawdzenie ca&#322;ej aplikacji w tym wykonanie wszystkich metod w template komponentu.</p>&#10;<p>Nie poniewa&#380; tabeli nie powinno interesowa&#263; &#380;e inna cze&#347;&#263; aplikacji si&#281; od&#347;wie&#380;y&#322;a a przynajmniej nie powinno mie&#263; to wp&#322;ywu na jej dzia&#322;anie.</p>&#10;<h2 id="rozwi&#261;zanie">Rozwi&#261;zanie</h2>&#10;<h3 id="jednolinijkowiec">Jednolinijkowiec</h3>&#10;<p>Wystarczy jedna linia do naprawienia animacji,</p>&#10;<pre><code class="prism language-typescript">@Component({&#10;  selector: 'app-results-table',&#10;  templateUrl: './results-table.component.html',&#10;  styleUrls: ['./results-table.component.css'],&#10;  standalone: true,&#10;  imports: [CommonModule],&#10;  changeDetection: ChangeDetectionStrategy.OnPush // &lt;- Ta linia&#10;})&#10;export class ResultsTableComponent {&#10;...&#10;</code></pre>&#10;<p>Po dodaniu jej i od&#347;wie&#380;eniu podgl&#261;du okr&#261;g b&#281;dzie si&#281; porusza&#322; tak p&#322;ynnie jak tylko potrafi i zadanie rozwi&#261;zane poniewa&#380; <code>ResultTableComponent</code> jest teraz odci&#281;t&#281; od sprawdzania zmian na g&#322;&#243;wnym drzewie &#347;ledzenia zmian jednak ma to swoje konsekwencje takie jak to &#380;e od teraz to my jako programi&#347;ci jeste&#347;my odpowiedzialni za stwierdzenia kiedy widok musi zosta&#263; od&#347;wie&#380;ony w komponencie i ka&#380;dym z jego dzieci.<br/>&#10;Jednak jest kilka rzeczy kt&#243;re automatycznie wymusz&#261; od&#347;wie&#380;enie komponentu.<br/>&#10;To jest zmiana w elementach u&#380;ywaj&#261;cych pipe <code>async</code> oraz zmiana referencji obiektu oznaczonego <code>@Input</code> <em>(wa&#380;ne, tylko zmiana referencji, wi&#281;c mutacje warto&#347;ci obiekt&#243;w nie s&#261; automatycznie wychwytywane)</em></p>&#10;<p>W tym wypadku &#322;atwo mo&#380;emy sprawdzi&#263; &#380;e jest to problemem je&#347;li zrobimy lekka zmian&#281; w serwisie zwracaj&#261;cym <code>todo</code><br/>&#10;z</p>&#10;<pre><code class="prism language-typescript"> getTodos(): Observable&lt;Todo[]&gt; {&#10;    return this.http&#10;      .get&lt;Todo[]&gt;('https://jsonplaceholder.typicode.com/todos')&#10;      .pipe(&#10;        map((results) =&gt;&#10;          results.slice(0, 15).map((todo) =&gt; ({&#10;            ...todo,&#10;            value: (Math.random() * 20_000_000) | 0,&#10;          }))&#10;        )&#10;      );&#10;  }&#10;</code></pre>&#10;<p>na</p>&#10;<pre><code class="prism language-typescript"> getTodos(): Observable&lt;Todo[]&gt; {&#10;    return this.http&#10;      .get&lt;Todo[]&gt;('https://jsonplaceholder.typicode.com/todos')&#10;      .pipe(&#10;        map((results) =&gt;&#10;          results.slice(0, 15).map((todo, index) =&gt; ({ //zwracamy index mapowanego elementu&#10;            ...todo,&#10;            value: (index * 1_000_000) | 0, // zapewniamy &#380;e value b&#281;dzie powtarzalne co request&#10;          }))&#10;        )&#10;      ).pipe(repeat({delay: 1000})); // powtarzamy request co sekund&#281; w nieskoczono&#347;&#263;&#10;  }&#10;</code></pre>&#10;<p>Po wprowadzeniu takiej zmiany animacja dzia&#322;a p&#322;ynnie z przeskokiem co r&#243;wno sekund&#281;. Dzieje si&#281; tak poniewa&#380; do obserwabli <code>$todos</code> przysz&#322;a nowa warto&#347;&#263; zatem pipe <code>async</code> wymusi&#322; od&#347;wie&#380;enie komponentu (dwa razy do tego bo mamy dwa powt&#243;rzenia tego pipe w template).</p>&#10;<h2 id="rozwi&#261;zanie-u-&#378;r&#243;d&#322;a">Rozwi&#261;zanie u &#378;r&#243;d&#322;a</h2>&#10;<p>To jest moja osobista opinia w tym miejscu ale uwa&#380;am &#380;e je&#347;li rozwi&#261;zaniem problemu z wydajno&#347;ci&#261; jest tylko i wy&#322;&#261;cznie zmiana strategii detekcji zmian na <code>OnPush</code> to przykryli&#347;my tylko problem i udajemy &#380;e go nie ma bo w 80% napotykanych przypadk&#243;w to wystarcza, jednak jak przyk&#322;ad w sytuacji jak po zmianie <code>getTodos()</code> wy&#380;ej &#322;atwo mo&#380;na znale&#378;&#263; scenariusz gdzie to nie wystarczy.</p>&#10;<h3 id="co-mo&#380;emy-z-tym-zrobi&#263;-w-takim-razie">Co mo&#380;emy z tym zrobi&#263; w takim razie?</h3>&#10;<p>Problem jest nie w tym jak dzia&#322;a angular to tylko w podej&#347;ciu do wyliczania sumy kwadrat&#243;w.<br/>&#10;Trzeba odpowiedzie&#263; sobie na pytanie kiedy si&#281; rezultat tej funkcji, a odpowied&#378; to nigdy poniewa&#380; jest w pe&#322;ni czysta funkcja zale&#380;na tylko od <em>n</em>.</p>&#10;<p>Wi&#281;c po co to liczy&#263; za ka&#380;dym razem je&#347;li wynik dla danego <em>n</em> si&#281; nie zmieni?</p>&#10;<p>No w&#322;a&#347;nie, nie ma po co tego robi&#263; wi&#281;c naszym wybawc&#261; w tym zadaniu jest <a href="https://en.wikipedia.org/wiki/Memoization">memoizacja</a>.</p>&#10;<p>Mo&#380;emy to podczas zadania zaimplementowa&#263; na szybko w formie</p>&#10;<pre><code class="prism language-typescript">export class ResultsTableComponent {&#10;  service = inject(TodosService);&#10;  todos$ = this.service.getTodos();&#10;  cacheLookup: { [value: number]: number } = {};&#10;  &#10;  sumSquaresUpToN(n: number) {&#10;      let sum = 0;&#10;      for (let i = 1; i &lt;= n; i++) {&#10;        sum += i ** 2;&#10;      }&#10;      return sum;&#10;   }&#10;   &#10;  memoSumSquaresUpToN(n: number): number {&#10;    if (n in this.cacheLookup) {&#10;      return this.cacheLookup[n];&#10;    } &#10;       &#10;    this.cacheLookup[n] = sumSquaresUpToN(n);&#10;    return this.cacheLookup[n];&#10;  }&#10;}&#10;</code></pre>&#10;<pre><code class="prism language-html">&lt;tr *ngFor=&#34;let todo of todos$ | async&#34;&gt;&#10;    &lt;td&gt;{{ todo.title }}&lt;/td&gt;&#10;    &lt;td&gt;{{ todo.completed }}&lt;/td&gt;&#10;    &lt;td&gt;{{ memoSumSquaresUpToN(todo.value) }}&lt;/td&gt;&#10;&lt;/tr&gt;&#10;</code></pre>&#10;<p>Jedyne co zmienili&#347;my to zadeklarowali&#347;my istnienie obiektu <code>cacheLookup</code>, dodali&#347;my metod&#281; <code>memoSumSquaresUpToN</code> kt&#243;ra sprawdzi czy dla danego <em>n</em> ju&#380; istnieje zapami&#281;tany wynik i go zwr&#243;ci je&#347;li istnieje a w przeciwnym wypadku wyliczymy go i zwr&#243;cimy &#347;wie&#380;e wyliczenie. Koniecznie te&#380; trzeba by&#322;o zmieni&#263; w template u&#380;ycie  <code>sumSquaresUpToN</code> na <code>memoSumSquaresUpToN</code> bo inaczej wszystko posz&#322;o by na marne.</p>&#10;<p>Dodatkowo mogliby&#347;my oznaczy&#263; <code>sumSquaresUpToN</code> jako metod&#281; prywatn&#261; &#380;eby nikogo nie korci&#322;o u&#380;y&#263; jej bezpo&#347;rednio z pomini&#281;ciem naszego zbawiennego cache.</p>&#10;<h3 id="reu&#380;ywalny-wariant">Reu&#380;ywalny wariant</h3>&#10;<p>Zak&#322;adaj&#261;c &#380;e potencjalnie w przysz&#322;o&#347;ci mo&#380;e si&#281; pojawi&#263; wi&#281;cej ci&#281;&#380;kich obliczeniowo funkcji kt&#243;re mogliby&#347;my zapami&#281;tywa&#263; ale bez ka&#380;dorazowego definiowania cache w komponencie oraz pisania kodu odpowiedzialnego za sprawdzanie czy mo&#380;emy wynik wyci&#261;gn&#261;&#263; z cache czy musimy go przeliczy&#263;, wtedy mo&#380;emy szybko w osobnym pliku napisa&#263; prost&#261; <a href="https://en.wikipedia.org/wiki/Higher-order_function">funkcje wy&#380;szego rz&#281;du</a></p>&#10;<pre><code class="prism language-typescript">const memoize = &lt;TInput = any, TOutput= any&gt;(fn: Function) =&gt; {&#10;  const cacheLookup: { [value: TInput]: TOutput} = {};&#10;  const cachedFunction = function (this: any, val: TInput ) {&#10;    if (n in this.cacheLookup) {&#10;      return this.cacheLookup[n];&#10;    }&#10;    cacheLookup[val] = fn.call(this, val))&#10;    return cacheLookup[val];&#10;  };&#10;  cachedFunction.cacheLookup= cache;&#10;  return cachedFunction ;&#10;};&#10;</code></pre>&#10;<p>i u&#380;y&#263; jej poprzez</p>&#10;<pre><code class="prism language-typescript">...&#10;import { memoize} from '/memoize.ts' // import naszej nowej funkjcji&#10;&#10;@Component({&#10;...&#10;})&#10;export class ResultsTableComponent {&#10;...&#10;  sumSquaresUpToN(n: number): number {&#10;    let sum = 0;&#10;    for (let i = 1; i &lt;= n; i++) {&#10;      sum += i ** 2;&#10;    }&#10;    return sum;&#10;  }&#10;  memoSumSquaresUpToN = memoize&lt;number, number&gt;(sumSquaresUpToN) // memoizacja ca&#322;ej funkcji sumSquaresUpToN&#10;}&#10;</code></pre>&#10;<p>oraz ponownie musimy zmieni&#263; w template u&#380;ywana metod&#281;.</p>&#10;<h3 id="runoutsideangular">RunOutsideAngular</h3>&#10;<p>Dodatkowym rozwi&#261;zaniem o kt&#243;rym mo&#380;na wspomnie&#263; jest u&#380;ycie <a href="https://angular.io/api/core/NgZone#runOutsideAngular">RunOutsideAngular</a> w celu oddelegowania kodu animacji do osobnego w&#261;tku nie wymuszaj&#261;cego wykonania sprawdzenia zmian.</p>&#10;</iframe>
